import argparse
import json
from dataclasses import asdict, dataclass, field, fields
from pathlib import Path
from typing import Optional


@dataclass(slots=True)
class ExploitContext:
    target_ip: str
    web_port: int
    api_port: int
    attacker_ip: str
    attacker_port: int
    payload_port: int
    protocol: str = "http"

    # Auth state
    token: Optional[str] = None
    token_name: Optional[str] = None
    session_cookie: Optional[str] = None

    # Metadata
    vuln_name: Optional[str] = None
    poc_id: Optional[str] = None
    notes: str = ""

    # Runtime-only fields
    output_path: Path = field(
        default_factory=lambda: Path("exploit_context.json"), repr=False
    )

    # --- Factory constructor from argparse ---

    @classmethod
    def from_args(cls, args: argparse.Namespace) -> "ExploitContext":
        """Build an ExploitContext from CLI arguments."""
        return cls(
            target_ip=args.target_ip,
            web_port=args.target_port,  # maps to --target-port
            api_port=args.target_api_port,  # maps to --target-api-port
            attacker_ip=args.listening_ip,  # maps to --listening-ip
            attacker_port=args.listening_port,  # maps to --listening-port
            payload_port=args.payload_port,  # maps to --payload-port
        )

    # --- URL helpers ---

    def _make_url(self, host: str, port: int) -> str:
        """Return protocol://host[:port], omitting default ports."""
        default_port = 80 if self.protocol == "http" else 443
        port_part = f":{port}" if port != default_port else ""
        return f"{self.protocol}://{host}{port_part}"

    def web_url(self) -> str:
        return self._make_url(self.target_ip, self.web_port)

    def api_url(self) -> str:
        return self._make_url(self.target_ip, self.api_port)

    def attacker_url(self) -> str:
        return self._make_url(self.attacker_ip, self.attacker_port)

    # --- Persistence ---

    def save(self) -> None:
        """Persist context to a JSON file (excluding runtime-only fields)."""
        serializable_dict = {
            k: str(v) if isinstance(v, Path) else v
            for k, v in asdict(self).items()
            if k != "output_path"
        }
        with self.output_path.open("w") as f:
            json.dump(serializable_dict, f, indent=2)

    @classmethod
    def from_file(cls, path: Path) -> "ExploitContext":
        """Create a new context from a saved file, ignoring unknown fields."""
        with path.open() as f:
            data = json.load(f)

        valid_keys = {f.name for f in fields(cls)}
        filtered_data = {k: v for k, v in data.items() if k in valid_keys}

        # Cast ports back to int if JSON saved them as str
        for port_key in ("web_port", "api_port", "attacker_port", "payload_port"):
            if port_key in filtered_data and isinstance(filtered_data[port_key], str):
                filtered_data[port_key] = int(filtered_data[port_key])

        ctx = cls(**filtered_data)
        ctx.output_path = path
        return ctx
